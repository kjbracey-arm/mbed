/* mbed Microcontroller Library
 * Copyright (c) 2018-2019 ARM Limited
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef MSTD_SPAN_H_
#define MSTD_SPAN_H_

#include <mstd_array>
#include <mstd_algorithm>
#include <mstd_cstddef>
#include <mstd_iterator>
#include <mstd_type_traits>
#include <mstd_utility>

#include "platform/mbed_assert.h"

namespace mstd {

/** \addtogroup platform-public-api */
/** @{*/

/**
 * \defgroup platform_Span span class
 * @{
 */

/**
 * Special value for the Extent parameter of span.
 * If the type uses this value, then the size of the array is stored in the object
 * at runtime.
 *
 * @relates span
 */
constexpr size_t dynamic_extent = size_t(-1);

template<typename ElementType, size_t Extent>
class span;

namespace impl {
template <typename ElementType, size_t Extent>
class span_base {
    ElementType *data_;
public:
    // We must have a constexpr constructor to be a literal type, so
    // MBED_CONSTEXPR_14_FN not used.
    constexpr span_base(ElementType *ptr, MBED_UNUSED size_t count) noexcept : data_(ptr)
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(count == Extent);
        MBED_ASSERT(Extent == 0 || ptr != nullptr);
#endif
    }

    /**
     * Return a pointer to the first element of the sequence or nullptr if the span
     * is empty().
     *
     * @return The pointer to the first element of the span.
     */
    constexpr ElementType *data() const noexcept
    {
        return data_;
    }

    /**
     * Return the size of the array viewed.
     *
     * @return The number of elements present in the array viewed.
     */
    constexpr size_t size() const noexcept
    {
        return Extent;
    }
};

template <typename ElementType>
class span_base<ElementType, dynamic_extent> {
    ElementType *data_;
    size_t size_;
public:
    // We must have a constexpr constructor to be a literal type, so
    // MBED_CONSTEXPR_14_FN not used.
    constexpr span_base(ElementType *ptr, size_t count) noexcept : data_(ptr), size_(count)
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(count == 0 || ptr != nullptr);
#endif
    }

    /**
     * Return a pointer to the first element of the sequence or nullptr if the span
     * is empty().
     *
     * @return The pointer to the first element of the span.
     */
    constexpr ElementType *data() const noexcept
    {
        return data_;
    }

    constexpr size_t size() const noexcept
    {
        return size_;
    }
};

template <typename>
struct is_span : false_type { };

template <typename ElementType, size_t Extent>
struct is_span<mstd::span<ElementType, Extent>> : true_type { };

template <typename>
struct is_mstd_array : false_type { };

template <typename ElementType, size_t Extent>
struct is_mstd_array<mstd::array<ElementType, Extent>> : true_type { };

template <typename, typename = void>
struct has_data_and_size : false_type { };

template <typename T>
struct has_data_and_size<T,
    void_t<decltype(mstd::data(mstd::declval<T &>())),
           decltype(mstd::size(mstd::declval<T &>()))>
    > : true_type { };

template <typename Container, typename ElementType>
struct has_convertible_data :
        is_convertible<
            remove_pointer_t<decltype(mstd::data(mstd::declval<Container &>()))>(*)[],
            ElementType(*)[]> { };

template <typename Container, typename ElementType>
struct is_spannable_container :
        conjunction<
            negation<is_span<remove_const_t<Container>>>,
            negation<is_mstd_array<remove_const_t<Container>>>,
            negation<is_array<Container>>,
            has_data_and_size<Container>,
            has_convertible_data<Container, ElementType>
        > { };

}
/**
 * Nonowning view to a sequence of contiguous elements.
 *
 * Spans encapsulate a pointer to a sequence of contiguous elements and its size
 * into a single object. span can replace the traditional pair of pointer and
 * size arguments passed as array definitions in function calls.
 *
 * @par Operations
 *
 * span objects can be copied and assigned like regular value types with the help
 * of the copy constructor or the copy assignment (=) operator.
 *
 * You can retrieve elements of the object with the subscript ([]) operator. You can access the
 * pointer to the first element of the sequence viewed with data().
 * The function size() returns the number of elements in the sequence, and
 * empty() informs whether there is any element in the sequence.
 *
 * You can slice span from the beginning of the sequence (first()), from the end
 * of the sequence (last()) or from an arbitrary point of the sequence (subspan()).
 *
 * @par Size encoding
 *
 * The size of the sequence can be encoded in the type itself or in the value of
 * the instance with the help of the template parameter Extent:
 *
 *   - span<uint8_t, 6>: span over a sequence of 6 elements.
 *   - span<uint8_t>: span over an arbitrary long sequence.
 *
 * When the size is encoded in the type itself, it is guaranteed that the span
 * view is a valid sequence (so data() cannot be nullptr unless Extent equals 0).
 * The type system also prevents automatic conversion from span of different
 * sizes. Finally, the span object is internally represented as a single pointer.
 *
 * When the size of the sequence viewed is encoded in the span value, span
 * instances can view an empty sequence. The function empty() helps client code
 * decide whether span is viewing valid content or not.
 *
 * @par Example
 *
 * - Encoding fixed size array: Array values in parameter decays automatically
 * to pointer, which leaves room for subtle bugs:
 *
 * @code
    typedef uint8_t mac_address_t[6];
    void process_mac(mac_address_t);

    // compile just fine
    uint8_t *invalid_value = nullptr;
    process_mac(invalid_value);


    // correct way
    typedef span<uint8_t, 6> mac_address_t;
    void process_mac(mac_address_t);

    // compilation error
    uint8_t *invalid_value = nullptr;
    process_mac(invalid_value);

    // compilation ok
    uint8_t valid_value[6];
    process_mac(valid_value);
 * @endcode
 *
 * - Arbitrary buffer: When dealing with multiple buffers, it becomes painful to
 * keep track of every buffer size and pointer.
 *
 * @code
    const uint8_t options_tag[OPTIONS_TAG_SIZE];

    struct parsed_value_t {
       uint8_t *header;
       size_t header_size;
       uint8_t *options;
       size_t options_size;
       uint8_t *payload;
       size_t payload_size;
    }

    parsed_value_t parse(uint8_t *buffer, size_t buffer_size)
    {
       parsed_value_t parsed_value { 0 };

       if (buffer != nullptr && buffer_size <= MINIMAL_BUFFER_SIZE) {
           return parsed_value;
       }

       parsed_value.header = buffer;
       parsed_value.header_size = BUFFER_HEADER_SIZE;

       if (memcmp(buffer + HEADER_OPTIONS_INDEX, options_tag, sizeof(options_tag)) == 0) {
           parsed_value.options = buffer + BUFFER_HEADER_SIZE;
           parsed_value.options_size = OPTIONS_SIZE;
           parsed_value.payload = buffer + BUFFER_HEADER_SIZE + OPTIONS_SIZE;
           parsed_value.payload_size = buffer_size - BUFFER_HEADER_SIZE + OPTIONS_SIZE;
       } else {
           parsed_value.payload = buffer + BUFFER_HEADER_SIZE;
           parsed_value.payload_size = buffer_size - BUFFER_HEADER_SIZE;
       }

       return parsed_value;
    }


    //with span
    struct parsed_value_t {
       span<uint8_t> header;
       span<uint8_t> options;
       span<uint8_t> payload;
    }

    parsed_value_t parse(const span<uint8_t> &buffer)
    {
       parsed_value_t parsed_value;

       if (buffer.size() <= MINIMAL_BUFFER_SIZE) {
           return parsed_value;
       }

       parsed_value.header = buffer.first(BUFFER_HEADER_SIZE);

       if (buffer.subspan<HEADER_OPTIONS_INDEX, sizeof(options_tag)>() == option_tag) {
           options = buffer.supspan(parsed_value.header.size(), OPTIONS_SIZE);
       }

       payload = buffer.subspan(parsed_value.header.size() + parsed_value.options.size());

       return parsed_value;
    }
 * @endcode
 *
 * @note You can create span instances with the help of the function template
 * make_span() and make_const_span().
 *
 * @note span<T, Extent> objects can be implicitly converted to span<T> objects
 * where required.
 *
 * @tparam ElementType type of objects the span views.
 *
 * @tparam Extent The size of the contiguous sequence viewed. The default value
 * dynamic_extent  is special because it allows construction of span objects of
 * any size (set at runtime).
 */
template<typename ElementType, size_t Extent = dynamic_extent>
class span : public impl::span_base<ElementType, Extent> {
    typedef impl::span_base<ElementType, Extent> base;

public:
    /**
     * Type of the element contained
     */
    typedef ElementType element_type;

    typedef remove_cv_t<ElementType> value_type;

    /**
     * Type of the index.
     */
    typedef size_t size_type; // Paper P1872R0 (2019-09-16)
    typedef size_t index_type; // C++20 draft N4835 (2019-10-08)
    typedef ptrdiff_t difference_type;

    /**
     * Pointer to an ElementType
     */
    typedef element_type *pointer;
    typedef const element_type *const_pointer;

    /**
     * Reference to an ElementType
     */
    typedef element_type &reference;
    typedef const element_type &const_reference;

    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef mstd::reverse_iterator<iterator> reverse_iterator;
    typedef mstd::reverse_iterator<const_iterator> const_reverse_iterator;

    /**
     * Size of the Extent; -1 if dynamic.
     */
    static constexpr size_type extent = Extent;

    /**
     * Construct an empty span.
     *
     * @post a call to size() returns 0, and data() returns nullptr.
     *
     * @note This function is not accessible if Extent != dynamic_extent or
     * Extent != 0 .
     */
    template <size_type Ext = Extent, enable_if_t<Ext == 0 || Ext == dynamic_extent, bool> = true>
    constexpr span() noexcept :
        base(nullptr, 0)
    {
    }

    /**
     * Construct a span from a pointer to a buffer and its size.
     *
     * @param ptr Pointer to the beginning of the data viewed.
     *
     * @param count Number of elements viewed.
     *
     * @pre [ptr, ptr + count) must be be a valid range.
     * @pre count must be equal to Extent.
     *
     * @post a call to size() returns Extent, and data() returns @p ptr.
     */
    constexpr span(pointer ptr, size_type count) :
        base(ptr, count)
    {
    }

    /**
     * Construct a span from the range [first, last).
     *
     * @param first Pointer to the beginning of the data viewed.
     * @param last End of the range (element after the last element).
     *
     * @pre [first, last) must be be a valid range.
     * @pre first <= last.
     * @pre if extent != dynamic_extent, last - first must be equal to Extent.
     *
     * @post a call to size() returns Extent, and data() returns @p first.
     */
    constexpr span(pointer first, pointer last) :
        base(first, last - first)
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(first <= last);
#endif
    }

    // AStyle ignore, not handling correctly below
    // *INDENT-OFF*
    /**
     * Construct a span from the reference to an array.
     *
     * @param arr Reference to the array viewed.
     *
     * @post a call to size() returns Extent, and data() returns a
     * pointer to elements.
     */
    template <size_t N,
        enable_if_t<extent == dynamic_extent || N == extent, bool> = true>
    constexpr span(element_type (&arr)[N]) noexcept :
        base(mstd::data(arr), N) { }

    template <size_t N,
        enable_if_t<(extent == dynamic_extent || N == extent) &&
                    is_convertible<value_type *, element_type *>::value, bool> = true>
    constexpr span(mstd::array<value_type, N> &arr) noexcept :
        base(mstd::data(arr), N)
    {
    }

    template <size_t N,
        enable_if_t<(extent == dynamic_extent || N == extent) &&
                    is_convertible<const value_type *, element_type *>::value, bool> = true>
    constexpr span(const mstd::array<value_type, N> &arr) noexcept :
        base(mstd::data(arr), N)
    {
    }


    /**
     * Construct a span object from another span.
     *
     * @param other The span object used to construct this.
     *
     * @note This span must have dynamic or matching extent.
     *
     * @note OtherElementType(*)[] must be convertible to ElementType(*)[].
     */
    template<typename OtherElementType, size_t OtherExtent,
             enable_if_t<(Extent == dynamic_extent || Extent == OtherExtent) &&
                         is_convertible<OtherElementType (*)[], ElementType (*)[]>::value, bool> = true>
    constexpr span(const span<OtherElementType, OtherExtent> &other) noexcept :
        base(other.data(), other.size())
    {
    }

    template <class Container,
              enable_if_t<extent == dynamic_extent &&
                          impl::is_spannable_container<Container, ElementType>::value, bool> = true>
    constexpr span(Container &cont):
        base(mstd::data(cont), mstd::size(cont))
    {
    }

    template <class Container,
              enable_if_t<extent == dynamic_extent &&
                          impl::is_spannable_container<const Container, ElementType>::value, bool> = true>
    constexpr span(const Container &cont):
        base(mstd::data(cont), mstd::size(cont))
    {
    }
    // *INDENT-ON*

    ~span() noexcept = default;

    constexpr span(const span &other) noexcept = default;

    using base::size;
    using base::data;

    /**
     * Return the size of the sequence viewed in bytes.
     *
     * @return The size of the sequence viewed in bytes.
     */
    constexpr size_type size_bytes() const
    {
        return size() * sizeof(element_type);
    }

    /**
     * Return if the sequence is empty or not.
     *
     * @return true if the sequence is empty and false otherwise.
     */
    constexpr bool empty() const noexcept
    {
        return size() == 0;
    }

    constexpr reference front() const
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(!empty());
#endif
        return *data();
    }

    constexpr reference back() const
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(!empty());
#endif
        return *(data() + (size() - 1));
    }

    /**
     * Returns a reference to the element at position @p idx.
     *
     * @param idx Index of the element to access.
     *
     * @return A reference to the element at the index specified in input.
     *
     * @pre idx < Extent.
     */
    constexpr reference operator[](size_type idx) const
    {
#if defined MBED_DEBUG && __cplusplus >= 201402
        MBED_ASSERT(idx < size());
#endif
        return *(data() + idx);
    }

    /**
     * Create a new span over the first @p Count elements of the existing view.
     *
     * @tparam Count The number of element viewed by the new span
     *
     * @return A new span over the first @p Count elements.
     *
     * @pre Count <= size().
     */
    template<size_t Count>
    MSTD_CONSTEXPR_FN_14 span<element_type, Count> first() const
    {
        static_assert(
            Extent == dynamic_extent || Count <= Extent,
            "Invalid subspan extent"
        );
#ifdef MBED_DEBUG
        MBED_ASSERT(Count <= size());
#endif
        return {data(), Count};
    }

    /**
     * Create a new span over the last @p Count elements of the existing view.
     *
     * @tparam Count The number of element viewed by the new span.
     *
     * @return A new span over the last @p Count elements.
     *
     * @pre Count <= size().
     */
    template<size_t Count>
    MSTD_CONSTEXPR_FN_14 span<element_type, Count> last() const
    {
        static_assert(
                Extent == dynamic_extent || Count <= Extent,
            "Invalid subspan extent"
        );
#ifdef MBED_DEBUG
        MBED_ASSERT(Count <= size());
#endif
        return {data() + (size() - Count), Count};
    }

    // AStyle ignore, not handling correctly below
    // *INDENT-OFF*
    /**
     * Create a subspan that is a view of other Count elements; the view starts at
     * element Offset.
     *
     * @tparam Offset The offset of the first element viewed by the subspan.
     *
     * @tparam Count The number of elements present in the subspan. If Count
     * is equal to dynamic_extent, then a span starting at offset and
     * containing the rest of the elements is returned.
     *
     * @return A subspan of this starting at Offset and Count long.
     */
    template<size_t Offset, size_t Count = dynamic_extent>
    MSTD_CONSTEXPR_FN_14 span<element_type,
                           Count != dynamic_extent ? Count :
                                                     (Extent != dynamic_extent ? Extent - Offset
                                                                               : dynamic_extent)>
    subspan() const
    {
        static_assert(
            Extent == dynamic_extent || Offset <= Extent,
            "Invalid subspan offset"
        );
        static_assert(
            Extent == dynamic_extent ||
            (Count == dynamic_extent) ||
            ((Count + Offset) <= Extent),
            "Invalid subspan count"
        );
#ifdef MBED_DEBUG
        MBED_ASSERT(Offset <= size());
        MBED_ASSERT(
            (Count == dynamic_extent) ||
            ((Count + Offset) <= size())
        );
#endif
        return {
            data() + Offset,
            Count != dynamic_extent ? Count : size() - Offset
        };
    }
    // *INDENT-ON*

    /**
     * Create a new span over the first @p count elements of the existing view.
     *
     * @param count The number of element viewed by the new span.
     *
     * @return A new span over the first @p count elements.
     */
    MSTD_CONSTEXPR_FN_14 span<element_type, dynamic_extent>first(size_type count) const
    {
#ifdef MBED_DEBUG
        MBED_ASSERT(count <= size());
#endif
        return {data(), count};
    }

    /**
     * Create a new span over the last @p count elements of the existing view.
     *
     * @param count The number of elements viewed by the new span.
     *
     * @return A new span over the last @p count elements.
     */
    MSTD_CONSTEXPR_FN_14 span<element_type, dynamic_extent> last(size_type count) const
    {
#ifdef MBED_DEBUG
        MBED_ASSERT(count <= size());
#endif
        return {data() + (size() - count), count};
    }

    /**
     * Create a subspan that is a view of other count elements; the view starts at
     * element offset.
     *
     * @param offset The offset of the first element viewed by the subspan.
     *
     * @param count The number of elements present in the subspan. If Count
     * is equal to dynamic_extent, then a span starting at offset and
     * containing the rest of the elements is returned.
     *
     * @return
     */
    MSTD_CONSTEXPR_FN_14 span<element_type, dynamic_extent>
    subspan(size_type offset, size_type count = dynamic_extent) const
    {
#ifdef MBED_DEBUG
        MBED_ASSERT(offset <= size());
        MBED_ASSERT(
            (count == dynamic_extent) ||
            ((count + offset) <= size())
        );
#endif
        return {
                   data() + offset,
                   count == dynamic_extent ? size() - offset : count
               };
    }

    constexpr iterator begin() const
    {
        return iterator(data());
    }

    constexpr iterator end() const
    {
        return begin() + size();
    }

    MSTD_CONSTEXPR_FN_14 reverse_iterator rbegin() const
    {
        return reverse_iterator(end());
    }

    MSTD_CONSTEXPR_FN_14 reverse_iterator rend() const
    {
        return reverse_iterator(begin());
    }

    constexpr const_iterator cbegin() const
    {
        return const_iterator(data());
    }

    constexpr const_iterator cend() const
    {
        return cbegin() + size();
    }

    MSTD_CONSTEXPR_FN_14 const_reverse_iterator crbegin() const
    {
        return const_reverse_iterator(cend());
    }

    MSTD_CONSTEXPR_FN_14 const_reverse_iterator crend() const
    {
        return const_reverse_iterator(cbegin());
    }
};

/**@}*/

/**@}*/

} // namespace mstd

namespace std {
// [span.tuple]
// Base templates for tuple_size, tuple_element and get are defined in <array>
// User specialization is permitted.
template<typename ElementType, size_t Extent>
struct tuple_size<mstd::span<ElementType, Extent>> : integral_constant<size_t, Extent> { };

template<typename ElementType>
struct tuple_size<mstd::span<ElementType, mstd::dynamic_extent>>; // not defined

template<size_t I, typename ElementType, size_t Extent>
struct tuple_element<I, mstd::span<ElementType, Extent>> : mstd::type_identity<ElementType> {
    static_assert(Extent != mstd::dynamic_extent, "tuple_element not available for dynamic span");
    static_assert(I < Extent, "span index out of bounds");
};

template <size_t I, typename ElementType, size_t Extent>
MSTD_CONSTEXPR_FN_14 ElementType &get(mstd::span<ElementType, Extent> s) noexcept
{
    static_assert(Extent != mstd::dynamic_extent, "get not available for dynamic span");
    static_assert(I < Extent, "span index out of bounds");
    return s[I];
}
} // namespace std

#endif /* MSTD_SPAN_H_ */
